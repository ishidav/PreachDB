%$Id: m2e_mapping.tex,v 1.3 2009/02/23 18:50:58 depaulfm Exp $
\chapter{Mur$\phi$ to Erlang Mapping}

\section{Semantic Mapping}

The main syntactic construct of a $mur\phi$ model is $rule$. The $rule$ 
construct implements
the guarded-commands semantic of $mur\phi$. A $rule$ comprises a $guard$ and a set
of $actions$. A $guard$ is an expression that evaluates to true (we say then that the 
guard fires) or false. A set of $actions$ is a set of statements that implements
a transition from a state to another. Statements are treated as ordinary constructs
that are 'easily' mapped to $functional$ $programming$ constructs. The important
semantic mapping, however, is the translation of $mur\phi$'s state and 
transition-relations encoding to $preach$.
Note that a state of a $mur\phi$ model is global. All state manipulation is atomic, 
however.
The $rule$ construct enforces atomicity. When multiple rules' guard fires, each
rules' actions are atomically and, semantically, non-deterministically executed --- 
all this is saying is that each fired rule is executed in an arbitrary order.
Therefore, we should preserve that semantic when mapping a $mur\phi$ model into
a $preach$ model.

Let's start by looking at how we encode a state in $preach$. Figure~\label{Sst} gives
a syntax tree for a $state$ description. Each state is represented by a 'label'
and a \underline{list}\footnote{Every underline word refers to an Erlang data-type or
keyword} 
 of 'encodings'. Both 'label' and 'encodings' are integers for now. We use the 
state's label to define which process owns it. 
As in  $mur\phi$, we implement the transition relation in Erlang as a set of rules.
In Figure~\label{TRst}, we define the syntax tree for the transition relation (TR). 
In order to preserve $mur\phi$'s semantics we encode the transition relation as
in Figure~\label{TRerl}.
%remember to describe how each guard is evaluated, each action is called and what
%murphi statements we are covering 

\begin{figure}
\begin{verbatim} 
<state>    ::= (label,encoding)
<label>    ::= integer
<encoding> ::= {integer [, integer] }
\end{verbatim}
\caption{State Syntax Tree}
\label{Sst}
\end{figure}


\begin{figure}
\begin{verbatim} 
<TR>    ::= {rule [; rule]}
<rule>  ::= (<guard>,<action>)
<guard> ::= <boolean_expression>
<action>::= { <murphi_statements> }
\end{verbatim}
\caption{Transition Relation Syntax Tree}
\label{TRst}
\end{figure}

\begin{algorithm}
\begin{algorithmic}
\STATE $function$ TR (integer: index, list: state)
\STATE \ [ S' $|$ guard(index,state) ],
\STATE \ TR(index-1,state);
\newline
\STATE $function$ TR (0, list: state)
\STATE \ \{[ S' ]\}.
\newline
\STATE $function$ guard (integer: index, list: state)
\IF {index = 0} 
\STATE return
\ELSIF {index = 1}
\STATE when $boolean\_expression\_1 \rightarrow$ action(integer: index, list: state)
\ELSIF {index = 2}
\STATE when $boolean\_expression\_1 \rightarrow$ action(integer: index, list: state)
\STATE $\vdots$
\ENDIF
\newline
\STATE $function$ action (integer: index, list: state)
\IF {index = 0} 
\STATE fun(X, list: state)
\ELSIF {index = 1}
\STATE fun(Y, list: state)
\STATE $\vdots$
\ENDIF


\caption{Transition Relation Erlang-pseudocode}
\label{TRerl}
\end{algorithmic}
\end{algorithm}

% OUT OF PLACE
%The $mur\phi$ model description is manually translated to a flat $mur\phi$ description
%so that procedures and functions are replaced by the actual statements they implement.

%\subsection{Data Types}
%A tuple represents a state

%\subsection{Procedures}
%\subsection{Functions}
%\subsection{Rules}

%\subsection{Statements}
%All statements are supported except $Undefine/clear$ since 

%-----------------------------------------------------------------
% Revision History 
% $Log: m2e_mapping.tex,v $
% Revision 1.3  2009/02/23 18:50:58  depaulfm
% 1st cut at pseudocode for TR
%
% Revision 1.2  2009/02/18 05:14:58  depaulfm
% Updated text to include a top-down description of the translation between murphi and preach
%
% Revision 1.1  2009/02/14 04:01:25  depaulfm
% Bootstrapping documentation for preach
%