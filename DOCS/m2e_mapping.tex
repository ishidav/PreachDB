%$Id: m2e_mapping.tex,v 1.4 2009/04/11 00:44:10 depaulfm Exp $
\chapter{Mur$\phi$ to Erlang Mapping}

\section{Semantic Mapping}

The main syntactic construct of a $mur\phi$ model is $rule$. The $rule$ 
construct implements
the guarded-commands semantic of $mur\phi$. A $rule$ comprises a $guard$ and a set
of $actions$. A $guard$ is an expression that evaluates to true (we say then that the 
guard fires) or false. A set of $actions$ is a set of statements that implements
a transition from a state to another. Statements are treated as ordinary constructs
that are 'easily' mapped to $functional$ $programming$ constructs. The important
semantic mapping, however, is the translation of $mur\phi$'s state and 
transition-relations encoding to $preach$.
Note that a state of a $mur\phi$ model is global. All state manipulation is atomic, 
however.
The $rule$ construct enforces atomicity. When multiple rules' guard fires, each
rules' actions are atomically and, semantically, non-deterministically executed --- 
all this is saying is that each fired rule is executed in an arbitrary order.
Therefore, we should preserve that semantic when mapping a $mur\phi$ model into
a $preach$ model.

Let's start by looking at how we encode a state in $preach$. Figure~\ref{fig:Sst} gives
a syntax tree for a $state$ description. Each state is represented by 
a \underline{list}\footnote{Every underline word refers to an Erlang data-type or
keyword} 
 of 'encodings'. This \underline{list} preserves a priori defined order of the models'
variables. A bound integer represents each 'encoding'.
As in  $mur\phi$, we implement the transition relation in Erlang as a set of rules.
In Figure~\ref{TRst}, we define the syntax tree for the transition relation. 
In order to preserve $mur\phi$'s semantics we encode the transition relation as
in Figure~\ref{TRerl}.
%remember to describe how each guard is evaluated, each action is called and what
%murphi statements we are covering 

\begin{figure}
\begin{verbatim} 
<state>    ::= <encoding>
<encoding> ::= {integer [, integer] }
<state[i]  ::= integer
\end{verbatim}
\caption{State Syntax Tree}
\label{fig:Sst}
\end{figure}


\begin{figure}
\begin{verbatim} 
<transition>  ::= {<rule> [; <rule>]}
<rule>        ::= guard \( <index>, <state> \) ->
                  case <index> of  
                  [ integer -> <expr> -> 
                              action \( <index>, <state> \)]

<expr>        ::=  \( expr \)
	             | <state>
	             | <state[i]>
	             | <integer>
	             | <expr> < <expr>
	             | <expr> <= <expr>
	             | <expr> > <expr>
	             | <expr> >= <expr>
	             | <expr> == <expr>
	             | <expr> != <expr>

<guard>       ::=
<action>      ::= { <murphi_statements> [; <murphi_statements>] }
\end{verbatim}
\caption{Transition Relation Syntax Tree}
\label{TRst}
\end{figure}

\begin{algorithm}
\begin{algorithmic}
\STATE $function$ transition (integer: index, list: state)
\STATE \ [ guard(index,state) $|$ transition (index-1,state) ];
\newline
\STATE $function$ transition (0, list: state)
\STATE \ [].
\newline
\STATE $function$ guard (integer: index, list: state)
\IF {index = 0} 
\STATE return
\ELSIF {index = 1}
\STATE when $boolean\_expression\_1 \rightarrow$ action(integer: index, list: state)
\ELSIF {index = 2}
\STATE when $boolean\_expression\_1 \rightarrow$ action(integer: index, list: state)
\STATE $\vdots$
\ENDIF
\newline
\STATE $function$ action (integer: index, list: state)
\IF {index = 0} 
\STATE fun(X, list: state)
\ELSIF {index = 1}
\STATE fun(Y, list: state)
\STATE $\vdots$
\ENDIF


\caption{Transition Relation Erlang-pseudocode}
\label{TRerl}
\end{algorithmic}
\end{algorithm}

% OUT OF PLACE
%The $mur\phi$ model description is manually translated to a flat $mur\phi$ description
%so that procedures and functions are replaced by the actual statements they implement.

%\subsection{Data Types}
%A tuple represents a state

%\subsection{Procedures}
%\subsection{Functions}
%\subsection{Rules}

%\subsection{Statements}
%All statements are supported except $Undefine/clear$ since 

%-----------------------------------------------------------------
% Revision History 
% $Log: m2e_mapping.tex,v $
% Revision 1.4  2009/04/11 00:44:10  depaulfm
% Checking in changes last made on 2009-Mar-02
%
% Revision 1.3  2009/02/23 18:50:58  depaulfm
% 1st cut at pseudocode for TR
%
% Revision 1.2  2009/02/18 05:14:58  depaulfm
% Updated text to include a top-down description of the translation between murphi and preach
%
% Revision 1.1  2009/02/14 04:01:25  depaulfm
% Bootstrapping documentation for preach
%