%--------------------------------------------------------------------------------
% LICENSE AGREEMENT
%
%  FileName                   [preach.erl]
%
%  PackageName                [preach]
%
%  Synopsis                   [Main erl module for Parallel Model Checking]
%
%  Author                     [BRAD BINGHAM, FLAVIO M DE PAULA]
%
%  Copyright                  [Copyright (C) 2009 University of British Columbia]
% 
%  This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
%--------------------------------------------------------------------------------
-module(preach).

-export([start/3,startWorker/1]).


%%----------------------------------------------------------------------
%% Function: start/3
%% Purpose : A timing wrapper for the parallel version of 
%%				our model checker.
%% Args    : P is the number of Erlang threads to use;
%%			Start is a list of states to initialize the state queue;
%%			End is the state we're looking for; may contain don't cares
%% Returns :
%%     
%%----------------------------------------------------------------------
start(Start,End,P) ->
 	T0 = now(),
	Names = initThreads([], P,End), 
	sendStates(Start, Names), 
	reach([], End, Names,sets:new()), % if this returns, End was not found
	io:format("=== State ~w was not found ===~n", [End]),
  	Dur = timer:now_diff(now(), T0)*1.0e-6,
	io:format("Execution time: ~w~n", [Dur]),
	done.	

sendStates([], _) ->
	ok;

%%----------------------------------------------------------------------
%% Function: sendStates/2
%% Purpose : Sends a list of states to their respective owners, one at a time.
%%			Thread i owns state n iff the sum of the variable values mod p is i, 
%%			where p is the number of threads. Assumes that states are are tuples.
%% Args    : First is the state we're currently sending
%%	     Rest are the rest of the states to send
%%	     Names is a list of PIDs
%% Returns :
%%     
%%----------------------------------------------------------------------
sendStates([First | Rest], Names) ->
	% a silly hash function
	Owner = lists:nth(1+(lists:sum(tuple_to_list(First)) rem length(Names)), Names),
%	Owner = lists:nth(1+(First rem length(Names)), Names), % mod calculation (rem is %)
%	io:format("Owner of state ~w is ~w - sending...~n", [First, Owner]), % debugging message
	Owner ! First,
	sendStates(Rest, Names).

%%----------------------------------------------------------------------
%% Function: initThreads/3
%% Purpose : Spawns worker threads. Passes the command-line input to each thread.
%%		Sends the list of all PIDs to each thread once they've all been spawned.
%% Args    : Names is a list of PIDs of threads spawned so far.
%%			NumThreads is the number of threads left to spawn.
%%			Data is the command-line input.
%% Returns :
%%     
%%----------------------------------------------------------------------
initThreads(Names, 1, _) ->	
	[self() | Names];
% Data is just End right now
initThreads(Names, NumThreads, Data) ->
	ID = spawn(preach, startWorker, [Data]),
	FullNames = initThreads([ID | Names], NumThreads-1, Data),
	ID ! FullNames. % send each worker the PID list

%%----------------------------------------------------------------------
%% Function: startWorker/1
%% Purpose : Initializes a worker thread by receiving the list of PIDs and 
%%		calling reach/4.
%% Args    : Trans is the list of transitions
%%	     End is the state we're looking for
%% Returns :
%%     
%%----------------------------------------------------------------------
startWorker(End) ->
    receive
        Names -> do_nothing % dummy RHS
    end,
	reach([], End, Names,sets:new()),
	ok.

%%----------------------------------------------------------------------
%% Function: reach/4
%% Purpose : Removes the first state from the list, 
%%		generates new states returned by the call to transition that
%%		are appended to the list of states. Recurses until there
%%		are no further states to process. 
%% Args    : FirstState is the state to remove from the state queue
%%	     RestStates is the remainder of the state queue
%%	     End is the state we seek - may contain don't cares 
%%	     BigList is a set of states that have been generated by this 
%%		thread so far. That is, BigList may contain states that
%%		do not belong to this thread. If we want to save memory
%%		at the cost of sending some unnecessary messages, the BigList
%%		should be altered to only include states that have previously
%%		entered this worker's state queue.
%%		NOTE: Any line involving the BigList probably has poor performance.
%%
%% Returns :
%%     
%%----------------------------------------------------------------------
reach([FirstState | RestStates], End, Names, BigList) ->
	%io:format("entering reach/4~n"),
	IsOldState = sets:is_element(FirstState, BigList),
	%io:format("about to enter the outer-if~n"),
	if IsOldState ->
		reach(RestStates, End, Names, BigList);
	true ->	
		NewStates = stress:transition(FirstState, start),
%		io:format("PID ~w: State ~w transitions to state(s) ~w~n", [self(),FirstState, NewStates]),
	
	%	move stateMatch to gospel later
		EndState = fun(X) -> stateMatch(X, End) end,
		EndFound = lists:any(EndState, NewStates),

	%	NewStates2 = sets:subtract(sets:from_list(NewStates), BigList), % remove states already in the big list
		if EndFound ->
			io:format("=== State ~w found by PID ~w ===~n", [End,self()]),
			io:format("PID ~w: # states visited was ~w~n", [self(), sets:size(BigList)]),
			terminateAll(Names);
		true ->
	%		io:format("about to recurse. FirstState is ~w, BigList size is ~w~n", [FirstState, sets:size(BigList)]), 
			sendStates(NewStates, Names),
			%sendStates(sets:to_list(NewStates), Names),
			reach(RestStates, End, Names, sets:add_element(FirstState, BigList)) % grow the big list
		end
	end;

% StateQ is empty, so check for messages. If none are found, we die
reach([], End, Names, BigList) ->
	NewQ = checkMessageQ(timeout, BigList), 
	NewQ2 = lists:usort(NewQ),
	if NewQ == [] ->
			[];
	   true ->
		% remove duplicate states before calling reach
		reach(NewQ2, End, Names, BigList)
	end.

%%----------------------------------------------------------------------
%% Function: checkMessageQ/2
%% Purpose : Polls for incoming messages for 1 second; terminates if no
%%		messages arrive.
%% Args    : timeout is atomic indicator that we are polling;
%%			notimeout performs a nonblocking receive of a state
%%			BigList is used only to report the size upon termination
%% Returns : List of received states
%%     
%%----------------------------------------------------------------------
checkMessageQ(timeout, BigList) ->
	receive
	die -> 
		io:format("PID ~w: # unique expanded states was ~w~n", [self(), sets:size(BigList)]),
		exit(normal);
        State ->
%		io:format("PID ~w received state ~w~n", [self(), State]), % for debugging
		[State | checkMessageQ(notimeout,BigList)]
	after 
		1000 -> % wait for 1000 ms   
		io:format("PID ~w: # unique expanded states was ~w~n", [self(), sets:size(BigList)]),
			[] 
	end;

% Get all queued messages without waiting
checkMessageQ(notimeout,BigList) ->
	receive
	die -> 
		io:format("PID ~w: # unique expanded states was ~w~n", [self(), sets:size(BigList)]),
		exit(normal);
        State ->
%		io:format("PID ~w received state ~w~n", [self(), State]), % for debugging
		[State | checkMessageQ(notimeout,BigList)]
	after 
		0 -> % wait for 0 ms   
			[] 
	end.

%%----------------------------------------------------------------------
%% Function: terminateAll/1
%% Purpose : Terminates all processes if the end state is found
%% Args    : A list of the PIDs to send die signals to
%% Returns :
%%     
%%----------------------------------------------------------------------
terminateAll([]) ->	
	exit(normal);
terminateAll([FirstPID | RestPID]) ->
	FirstPID ! die,
	terminateAll(RestPID).


%% the following functions to be removed. For "simple" testing only.
%% currently, transition, guard and action should all be implemented
%% in gospel. stateMatch should be implemented elsewhere, but we're
%% not sure where it should go at the moment.

%% Default transition unless we're MC-ing someting specific
transition(State, start) ->
	T = transition(2, State), % 2 is the number of guarded commands
	[X || X <- T, X /= null];
transition(0, _) ->
	[];
transition(Index, State) ->
	[guard(Index, State) | transition(Index-1, State)].
	
%% Default guard
guard(Index, State) ->
	case Index of
		1 -> 	if 
				State == {0,0} -> action(Index, State);
				true -> null
			end;
		2 ->	if 
				((State == {1,0}) or (State == {0,1})) -> action(Index, State);
				true -> null
			end
	end.

% action may be a function of State, but not for the simple example
action(Index, State) ->
	case Index of
		1 -> 	{0,1};
		2 ->	{0,0}
	end.

% may need to allow End to be a list of states, possibly
% with don't care variables
stateMatch(State, End) ->
	Pairs = lists:zip(tuple_to_list(State), tuple_to_list(End)),
	Eq = fun({X,Y}) -> (X == Y) or (Y == dc) end,
	lists:all(Eq, Pairs).



%--------------------------------------------------------------------------------
%                             Revision History
%
%
% $Log: preach.erl,v $
% Revision 1.5  2009/03/14 00:20:44  binghamb
% No longer caching ALL states generated. Instead, store all states OWNED by a given processor. This change increases the number of messages but decreases the upper bound on memory per process.
%
% Revision 1.4  2009/03/10 20:25:02  binghamb
% One line change: dek:transition -> transition
%
% Revision 1.3  2009/03/10 20:22:37  binghamb
% Compatable with dek.m. Changed main function start, now preach:start(Start,End,P).
%
% Revision 1.2  2009/02/23 02:43:40  binghamb
% Deleted some commented out code and filled in details in function/module headers
%
% Revision 1.1  2009/02/14 00:53:47  depaulfm
% Continue Bootstrapping repository
%
